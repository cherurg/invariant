// Generated by CoffeeScript 1.9.1
(function() {
  var G, derivative, expected, ff, getPath, inf, multiply, normalizeMatrix, transposition;

  transposition = function(G) {
    var A, el, i, j, k, l, len1, len2, row;
    A = (function() {
      var k, len1, results;
      results = [];
      for (k = 0, len1 = G.length; k < len1; k++) {
        row = G[k];
        results.push((function() {
          var l, len2, results1;
          results1 = [];
          for (l = 0, len2 = row.length; l < len2; l++) {
            el = row[l];
            results1.push(null);
          }
          return results1;
        })());
      }
      return results;
    })();
    for (i = k = 0, len1 = G.length; k < len1; i = ++k) {
      row = G[i];
      for (j = l = 0, len2 = row.length; l < len2; j = ++l) {
        el = row[j];
        A[j][i] = el;
      }
    }
    return A;
  };

  normalizeMatrix = function(A) {
    var B, el, i, j, k, ref, row;
    B = (function() {
      var k, len1, results;
      results = [];
      for (i = k = 0, len1 = A.length; k < len1; i = ++k) {
        row = A[i];
        results.push((function() {
          var l, len2, results1;
          results1 = [];
          for (j = l = 0, len2 = row.length; l < len2; j = ++l) {
            el = row[j];
            results1.push(Number.isFinite(el) && el !== 0 ? 1 : 0);
          }
          return results1;
        })());
      }
      return results;
    })();
    for (i = k = 0, ref = A.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      B[i][i] = 1;
    }
    return B;
  };

  multiply = function(s1, s2) {
    var el, i, k, len1, sum;
    sum = false;
    for (i = k = 0, len1 = s1.length; k < len1; i = ++k) {
      el = s1[i];
      sum = sum || !!s1[i] * s2[i];
    }
    return sum;
  };

  derivative = function(G) {
    var A, At, i, j, k, l, len, len1, len2, s1, s2;
    A = normalizeMatrix(G);
    len = A.length;
    while (len--) {
      At = transposition(A);
      for (i = k = 0, len1 = A.length; k < len1; i = ++k) {
        s1 = A[i];
        for (j = l = 0, len2 = At.length; l < len2; j = ++l) {
          s2 = At[j];
          A[i][j] = multiply(s1, s2);
        }
      }
    }
    return A;
  };

  getPath = function(G, i, j) {
    var colors, el, index, k, l, len1, len2, node, p, path, ref, stack, v;
    colors = [];
    stack = [i];
    path = [];
    while (stack.length !== 0) {
      v = stack.pop();
      path.push(v);
      colors[v] = true;
      if (v === j) {
        path.reverse();
        p = [];
        for (k = 0, len1 = path.length; k < len1; k++) {
          node = path[k];
          p.push(node);
          if (node === i) {
            p.reverse();
            return p;
          }
        }
      }
      ref = G[v];
      for (index = l = 0, len2 = ref.length; l < len2; index = ++l) {
        el = ref[index];
        if (colors[index] == null) {
          if (Number.isFinite(el) && el !== 0) {
            stack.push(index);
          }
        }
      }
    }
    return false;
  };

  ff = function(G, s, t) {
    var C, Gf, cfp, edge, edges, el, f, i, j, k, l, len1, len2, len3, m, n, p, ref, row, source, target;
    f = (function() {
      var k, len1, results;
      results = [];
      for (k = 0, len1 = G.length; k < len1; k++) {
        row = G[k];
        results.push((function() {
          var l, len2, results1;
          results1 = [];
          for (l = 0, len2 = row.length; l < len2; l++) {
            el = row[l];
            results1.push(0);
          }
          return results1;
        })());
      }
      return results;
    })();
    C = (function() {
      var k, len1, results;
      results = [];
      for (k = 0, len1 = G.length; k < len1; k++) {
        row = G[k];
        results.push((function() {
          var l, len2, results1;
          results1 = [];
          for (l = 0, len2 = row.length; l < len2; l++) {
            el = row[l];
            results1.push(Number.isFinite(el) ? el : 0);
          }
          return results1;
        })());
      }
      return results;
    })();
    Gf = (function() {
      var k, len1, results;
      results = [];
      for (k = 0, len1 = C.length; k < len1; k++) {
        row = C[k];
        results.push((function() {
          var l, len2, results1;
          results1 = [];
          for (l = 0, len2 = row.length; l < len2; l++) {
            el = row[l];
            results1.push(el);
          }
          return results1;
        })());
      }
      return results;
    })();
    while (p = getPath(Gf, s, t)) {
      edges = [];
      for (i = k = 1, ref = p.length; 1 <= ref ? k < ref : k > ref; i = 1 <= ref ? ++k : --k) {
        source = p[i - 1];
        target = p[i];
        edges.push({
          source: source,
          target: target,
          weight: Gf[source][target]
        });
      }
      edges.sort(function(a, b) {
        return a.weight - b.weight;
      });
      cfp = edges[0].weight;
      for (l = 0, len1 = edges.length; l < len1; l++) {
        edge = edges[l];
        f[edge.source][edge.target] += cfp;
        f[edge.target][edge.source] -= cfp;
      }
      for (i = m = 0, len2 = Gf.length; m < len2; i = ++m) {
        row = Gf[i];
        for (j = n = 0, len3 = row.length; n < len3; j = ++n) {
          el = row[j];
          Gf[i][j] = C[i][j] - f[i][j];
        }
      }
    }
    return f;
  };

  inf = Number.POSITIVE_INFINITY;

  G = [[0, 3, 3, inf, inf, inf], [inf, 0, inf, 2, 1, inf], [inf, inf, 0, inf, 3, inf], [inf, inf, inf, 0, inf, 3], [inf, inf, inf, inf, 0, 4], [inf, inf, inf, inf, inf, 0]];

  console.log("Real result: ");

  console.log(ff(G, 0, 5));

  expected = [[0, 3, 3, 0, 0, 0], [-3, 0, 0, 2, 1, 0], [-3, 0, 0, 0, 3, 0], [0, -2, 0, 0, 0, 2], [0, -1, -3, 0, 0, 4], [0, 0, 0, -2, -4, 0]];

  console.log("\nExpected result:");

  console.log(expected);

}).call(this);
