Граф
==
![Alt text](graph.png "")

Описывается матрицей (вариант 001):

    inf = Number.POSITIVE_INFINITY
    W = [
      [0,   2,   1,   inf, inf, inf],
      [2,   0,   inf, 2,   1,   inf],
      [1,   inf, 0,   4,   1,   inf],
      [inf, 2,   4,   0,   inf, 1  ],
      [inf, 1,   1,   inf, 0,   1  ],
      [inf, inf, inf, 1,   1,   0  ]
    ]

Мнимальные пути от первой вершины до каждой другой по порядку: [0, 2, 1, 4, 2, 3].

Алгоритм Дийкстры
==
Реализиация на literate coffeescript и доказательство корректности.

Метод принимает два аргумента: граф в виде матрицы и вершину, до которой нужно найти минимальный путь.

    dijkstra = (W, j0) ->
        l = []
        m = 1

Так как матрица квадратная, то число вершин `n` является любой из сторон матрицы:

        n = W.length

Берем каждую ячейку из нулевой строки матрицы графа и кладем эту величину в массив `l`. После выполнения этого цикла в *i*-ом элементе массива `l` будет содержаться длина пути от первой вершины до вершины *i* за один шаг. Иначе говоря, массив `l` будет показывать, сколько стоит добраться из первой вершины до каждой за один шаг.

        for edge in W[0]
            l.push edge

Рассмотрим следующий инвариант: массив `l` содержит минимальные длины путей не более чем за `m` шагов из первой вершины в каждую. До входа в следующий цикл этот инвариант выполняется, т.к. `l` уже содержит минимальные длины путей из первой вершины в каждую за `m = 1` шаг. На каждом шаге цикла инвариант сохраняется, т.к. для каждой вершины `j` мы пытаемся найти путь покороче, который проходт через какую-нибудь вершину `k`. Таким образом, инвариант не нарушается во время выполнения всего цикла.

Очевидно, что цикл заверштся, т.к. на каждом шаге переменная `m` увеличивается на 1, и условие цикла `m < n`. Вложенные циклы также завершатся, т.к. они итерируются по `j` и `k` от `1` до `n`, при этом внутри тел циклов эти переменные не меняются.

Заметим теперь, что при сохранении истинности инварианта после выполнения всего цикла `while` массив `l` будет содержать кратчайшие длины путей, состоящих не более чем из `n` шагов, от первой вершины к каждой другой.

        while m < n
            m += 1

            for j in [0...n]
                for k in [0...n]
                    l[j] = Math.min(l[j], l[k] + W[k][j])

Возвращаем искомую длину пути от первой вершины до вершины j0:

        return l[j0]

Подводя итог, мы показали корректность алгоритма и привели его реализацию.

Запустим процедуру для каждой вершины и выведем результат в консоль:

    dijkstraResult = (dijkstra(W, index) for index in [0..5])
    console.log dijkstraResult

Вывод программы корректен: [ 0, 2, 1, 4, 2, 3 ].


Максимум
==


    maximum = (W, j0) ->
      l = []
      m = 1
      n = W.length
      for edge in W[0]
        l.push edge

      while m < n
        m += 1

        for j in [0...n]
          for k in [0...n]
            l[j] = Math.max(l[j], l[k] + W[k][j])

      return l[j0]

Этот код не будет работать как ожидается. Причина простая: максимальный путь в
данном графе имеет бесконечную длину из-за наличия циклов. Таким образом, нет
необходимости запускать код: любой результат, отличный от бесконечности будет
неверным. Если взять полный граф, где все вершины соединены со всеми, то пути в
ответе не будут бесконечными из-за конечности числа шагов в алгоритме. Такой
граф будет контр-примером.

Procedure 3
==

    procedure3 = (W, j0) ->
      d = []
      k = 0
      n = W.length
      for arr in W
        d.push([])
        for edge in arr
          d[d.length - 1].push(edge)

      while k < n
        for i in [0...n]
          for j in [0...n]
            d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j])

        k += 1

      return d[0][j0]

    console.log (procedure3(W, i) for i in [0..5])

Код работает похожим образом, как и в первом примере, и инвариант цикла похожий.
d[i][j] хранит в себе кратчайший путь из i в j за k шагов. Доказательство
аналогично первому. Алгоритм на тестовых данных выдает результат такой же, как и
первый, работает корректно.
